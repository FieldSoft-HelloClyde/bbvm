package parser

import "github.com/wenerme/bbvm/libbbvm/asm"

# TODO Negative integer
# TODO Pseudo data instruction
type BBAsm Peg {
	parser
}

#-------------------------------------------------------------------------
# Instructions
#-------------------------------------------------------------------------
Start <- ( Spacing Line? NL{p.line++} )* EOT

Line <- ( Comment
        / Label
        / Inst
        / Pseudo ){p.PopAssembly()} (Comment {p.PopAssembly();p.AddComment()})?

Comment <- SEMICOLON <(!NL .)*> {p.Push(&asm.Comment{});p.Push(text)}
Label <- COLON <Identifier> {p.Push(&asm.Label{});p.Push(text)}

Inst <-  EXIT
		/ RET
		/ NOP
        / ( CALL / PUSH / POP / JMP ) Operand
        / ( IN / OUT ) Operand COMMA Operand
        / CAL <DATA_TYPE>{p.Push(lookup(asm.T_INT,text))} <CAL_OP>{p.Push(lookup(asm.CAL_ADD,text))} Operand COMMA Operand
        / LD <DATA_TYPE>{p.Push(lookup(asm.T_INT,text))} Operand COMMA Operand
        / CMP <DATA_TYPE>{p.Push(lookup(asm.T_INT,text))} Operand COMMA Operand
        / JPC <CMP_OP>{p.Push(lookup(asm.CMP_A,text))}  Operand

Pseudo <- BLOCK <IntegerLiteral>{p.Push(text)} Space <IntegerLiteral>{p.Push(text)}

Operand <- (<Identifier> 				{p.Push(CreateOperand(text,false,true))}
        / LBRK <Identifier> RBRK 		{p.Push(CreateOperand(text,false,false))}
        / <IntegerLiteral> 				{p.Push(CreateOperand(text,true,true))}
        / LBRK <IntegerLiteral> RBRK 	{p.Push(CreateOperand(text,true,false))}
        #/ FloatLiteral
        / Literal
        ) Spacing

#=========================================================================
#  Lexical Structure
#=========================================================================
#-------------------------------------------------------------------------
#  Spacing
#-------------------------------------------------------------------------
Spacing           <-  [ \t\r\f]*
Space           <-  [ \t\r\f]+

#-------------------------------------------------------------------------
#  Identifiers
#-------------------------------------------------------------------------
Identifier <- Letter LetterOrDigit* Spacing

Letter <- [a-z] / [A-Z] / [_$]

LetterOrDigit <- [a-z] / [A-Z] / [0-9] / [_$]

#-------------------------------------------------------------------------
# Keyword
#-------------------------------------------------------------------------

EXIT 	<- "EXIT" 	Spacing	{p.PushInst(asm.OP_EXIT)}
RET 	<- "RET" 	Spacing {p.PushInst(asm.OP_RET)}
NOP 	<- "NOP" 	Spacing {p.PushInst(asm.OP_NOP)}

CALL 	<- "CALL" 	Space 	{p.PushInst(asm.OP_CALL)}
PUSH 	<- "PUSH" 	Space 	{p.PushInst(asm.OP_PUSH)}
POP 	<- "POP" 	Space 	{p.PushInst(asm.OP_POP)}
JMP 	<- "JMP" 	Space 	{p.PushInst(asm.OP_JMP)}

IN 		<- "IN" 	Space 	{p.PushInst(asm.OP_IN)}
OUT 	<- "OUT" 	Space 	{p.PushInst(asm.OP_OUT)}

CAL 	<- "CAL" 	Space 	{p.PushInst(asm.OP_CAL)}

LD 		<- "LD" 	Space 	{p.PushInst(asm.OP_LD)}
CMP 	<- "CMP" 	Space 	{p.PushInst(asm.OP_CMP)}

JPC 	<- "JPC" 	Space 	{p.PushInst(asm.OP_JPC)}

BLOCK 	<- ".BLOCK" 	Space {p.Push(&asm.PseudoBlock{})}

CAL_OP <- ( "ADD" / "SUB" / "MUL" / "DIV" / "MOD" ) Space
CMP_OP <- ( "Z" / "B" / "BE" / "A" / "AE" / "NZ" ) Space

DATA_TYPE       <-  ( "DWORD" / "WORD" / "BYTE" / "FLOAT" / "INT" ) Space

#-------------------------------------------------------------------------
# Separators, Operators
#-------------------------------------------------------------------------
LBRK            <-  '['        Spacing
#LPAR            <-  '('        Spacing
RBRK            <-  ']'        Spacing
#RPAR            <-  ')'        Spacing
COMMA           <-  ','        Spacing
SEMICOLON <- ";"
COLON <- ':' Spacing
NL              <-  '\n'
EOT             <-  !.


#-------------------------------------------------------------------------
# Literals
#-------------------------------------------------------------------------

Literal
   <- ( FloatLiteral
      / IntegerLiteral          # May be a prefix of FloatLiteral
      / CharLiteral
      / StringLiteral
      ) Spacing

IntegerLiteral
   <- HexNumeral
      / BinaryNumeral
      / OctalNumeral            # May be a prefix of HexNumeral or BinaryNumeral
      / DecimalNumeral          # May be a prefix of OctalNumeral

DecimalNumeral <- '0' / [1-9] ([_]* [0-9])*

HexNumeral     <- ('0x' / '0X') HexDigits

BinaryNumeral  <- ('0b' / '0B') [01] ([_]* [01])*

OctalNumeral   <- '0' ([_]* [0-7])+

FloatLiteral   <- HexFloat / DecimalFloat

DecimalFloat
   <- Digits '.' Digits?  Exponent? [fFdD]?
    / '.' Digits Exponent? [fFdD]?
    / Digits Exponent [fFdD]?
    / Digits Exponent? [fFdD]

Exponent <- [eE] [+\-]? Digits

HexFloat <- HexSignificand BinaryExponent [fFdD]?

HexSignificand
   <- ('0x' / '0X') HexDigits? '.' HexDigits
    / HexNumeral '.'?                           # May be a prefix of above

BinaryExponent <- [pP] [+\-]? Digits

Digits <- [0-9]([_]*[0-9])*

HexDigits <- HexDigit ([_]*HexDigit)*

HexDigit <- [a-f] / [A-F] / [0-9]

CharLiteral <- ['] (Escape / !['\\] .) [']

StringLiteral <- '\"' (Escape / !["\\\n\r] .)* '\"'

Escape <- '\\' ([btnfr"'\\] / OctalEscape / UnicodeEscape)

OctalEscape
   <- [0-3][0-7][0-7]
    / [0-7][0-7]
    / [0-7]

UnicodeEscape
   <- 'u'+ HexDigit HexDigit HexDigit HexDigit

