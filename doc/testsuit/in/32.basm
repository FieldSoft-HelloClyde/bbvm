; 32,33,34,35
; 32 | 整数转换为字符串 | r3的值 | r1:整数<br>r3:目标字符串 | r3所代表字符串的内容被修改
in r3, 2
ld int r2, STR
in r0, 5

ld int r1, 123
in r0, 32

out 0, r1; 输出: 123
out 1, r0; 输出: 123
out 1, r3; 输出: 123

; 33
ld int r3, INT_STR
in r0, 33
out 0, r0; 输出: 12345

; 34
in r0, 34
out 0, r0; 输出: 49

; 35
; 左取字符串 | r3的值 | r1:截取长度<br>r2:源字符串<br>r3:目标字符串 | r3所代表字符串的内容被修改 （此端口似乎不正常）
; BUG: 需要传入有内容的字符串
in r3, 2
ld int r2, EMPTY
in r0, 5
ld int [EMPTY_HDL], r3

in r3, 2
ld int r2, STR
in r0, 5
ld int [STR_HDL], r3

; BUG: PC 上该demo会出问题,结果为 ABCXYZ, r3句柄值没变
; BUG: 在汇编操作35 36端口的时候,长度会加一~
ld int r3, [EMPTY_HDL]
ld int r2, STR
ld int r1, 3
in r0, 35
out 1, r0; 输出: abc
out 1, r3; 输出: abc

; 36
ld int r1, 1
in r0, 36
out 1, r0; 输出: g
out 1, r3; 输出: g
out 0, r3; 输出: -2

; BUG: PC 上该demo会出问题,需要确保 r3足够的长度,否则会返回r2的值
ld int r2, EMPTY
in r0, 5

; BUG: 长度加了一
ld int r2, STR
ld int r1, 3
in r0, 36
out 1, r0; 输出: efg
out 0, r3; 输出: -2

exit
DATA EMPTY char "ABCXYZ",0
DATA STR char "abcdefg",0
DATA EMPTY_HDL int 0
DATA STR_HDL int 0
DATA INT_STR char "12345.99",0